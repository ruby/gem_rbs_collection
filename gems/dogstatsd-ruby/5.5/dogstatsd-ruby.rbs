# = Datadog::Statsd: A DogStatsd client (https://www.datadoghq.com)
#
# @example Set up a global Statsd client for a server on localhost:8125
#   require 'datadog/statsd'
#   $statsd = Datadog::Statsd.new 'localhost', 8125
# @example Send some stats
#   $statsd.increment 'page.views'
#   $statsd.timing 'page.load', 320
#   $statsd.gauge 'users.online', 100
# @example Use {#time} to time the execution of a block
#   $statsd.time('account.activate') { @account.activate! }
# @example Create a namespaced statsd client and increment 'account.activate'
#   statsd = Datadog::Statsd.new 'localhost', 8125, :namespace => 'account'
#   statsd.increment 'activate'
# @example Create a statsd client with global tags
#   statsd = Datadog::Statsd.new 'localhost', 8125, tags: 'tag1:true'
module Datadog
  class Statsd
    class Error < StandardError
    end

    OK: Integer

    WARNING: Integer

    CRITICAL: Integer

    UNKNOWN: Integer

    UDP_DEFAULT_BUFFER_SIZE: Integer

    UDS_DEFAULT_BUFFER_SIZE: Integer

    DEFAULT_BUFFER_POOL_SIZE: Integer

    UDP_DEFAULT_SENDER_QUEUE_SIZE: Integer

    UDS_DEFAULT_SENDER_QUEUE_SIZE: Integer

    MAX_EVENT_SIZE: Integer

    # minimum flush interval for the telemetry in seconds
    DEFAULT_TELEMETRY_FLUSH_INTERVAL: Integer

    COUNTER_TYPE: String

    GAUGE_TYPE: String

    HISTOGRAM_TYPE: String

    DISTRIBUTION_TYPE: String

    TIMING_TYPE: String

    SET_TYPE: String

    # A namespace to prepend to all statsd calls. Defaults to no namespace.
    attr_reader namespace: String

    # Global tags to be added to every statsd call. Defaults to no tags.
    def tags: () -> untyped

    # Default sample rate
    attr_reader sample_rate: Float

    # @param [String] host your statsd host
    # @param [Integer] port your statsd port
    # @option [String] namespace set a namespace to be prepended to every metric name
    # @option [Array<String>|Hash] tags tags to be added to every metric
    # @option [Logger] logger for debugging
    # @option [Integer] buffer_max_payload_size max bytes to buffer
    # @option [Integer] buffer_max_pool_size max messages to buffer
    # @option [Integer] sender_queue_size size of the sender queue in number of buffers (multi-thread only)
    # @option [Numeric] buffer_flush_interval interval in second to flush buffer
    # @option [String] socket_path unix socket path
    # @option [Float] default sample rate if not overridden
    # @option [Boolean] single_thread flushes the metrics on the main thread instead of in a companion thread
    def initialize: (
      ?String? host,
      ?Integer? port,
      ?socket_path: String?,
      ?namespace: String?,
      ?tags: Array[String] | Hash[String, String]?,
      ?sample_rate: Float?,
      ?buffer_max_payload_size: Integer?,
      ?buffer_max_pool_size: Integer?,
      ?buffer_overflowing_stategy: Symbol,
      ?buffer_flush_interval: Numeric?,
      ?sender_queue_size: Integer?,
      ?logger: Logger?,
      ?single_thread: bool,
      ?telemetry_enable: bool,
      ?telemetry_flush_interval: Integer)
    -> void

    # yield a new instance to a block and close it when done
    # for short-term use-cases that don't want to close the socket manually
    # TODO: replace with ... once we are on ruby 2.7
    def self.open: [T] (
      ?String? host,
      ?Integer? port,
      ?socket_path: String?,
      ?namespace: String?,
      ?tags: Array[String] | Hash[String, String]?,
      ?sample_rate: Float?,
      ?buffer_max_payload_size: Integer?,
      ?buffer_max_pool_size: Integer?,
      ?buffer_overflowing_stategy: Symbol,
      ?buffer_flush_interval: Numeric?,
      ?sender_queue_size: Integer?,
      ?logger: Logger?,
      ?single_thread: bool,
      ?telemetry_enable: bool,
      ?telemetry_flush_interval: Integer
    ) { (instance) -> T } -> T

    # Sends an increment (count = 1) for the given stat to the statsd server.
    #
    # @param [String] stat stat name
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @option opts [Numeric] :by increment value, default 1
    # @see #count
    def increment: (String stat, Numeric sample_rate) -> void
                 | (String stat, ?Hash[Symbol, untyped] opts) -> void

    # Sends a decrement (count = -1) for the given stat to the statsd server.
    #
    # @param [String] stat stat name
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @option opts [Numeric] :by decrement value, default 1
    # @see #count
    def decrement: (String stat, Numeric sample_rate) -> void
                 | (String stat, ?Hash[Symbol, untyped] opts) -> void

    # Sends an arbitrary count for the given stat to the statsd server.
    #
    # @param [String] stat stat name
    # @param [Integer] count count
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    def count: (String stat, Integer count, ?Hash[Symbol, untyped] opts) -> void

    # Sends an arbitrary gauge value for the given stat to the statsd server.
    #
    # This is useful for recording things like available disk space,
    # memory usage, and the like, which have different semantics than
    # counters.
    #
    # @param [String] stat stat name.
    # @param [Numeric] value gauge value.
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @example Report the current user count:
    #   $statsd.gauge('user.count', User.count)
    def gauge: (String stat, Numeric value, Numeric sample_rate) -> void
             | (String stat, Numeric value, ?Hash[Symbol, untyped] opts) -> void

    # Sends a value to be tracked as a histogram to the statsd server.
    #
    # @param [String] stat stat name.
    # @param [Numeric] value histogram value.
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @example Report the current user count:
    #   $statsd.histogram('user.count', User.count)
    def histogram: (String stat, Numeric value, ?Hash[Symbol, untyped] opts) -> void

    # Sends a value to be tracked as a distribution to the statsd server.
    #
    # @param [String] stat stat name.
    # @param [Numeric] value distribution value.
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @example Report the current user count:
    #   $statsd.distribution('user.count', User.count)
    def distribution: (String stat, Numeric value, ?Hash[Symbol, untyped] opts) -> void

    # Reports execution time of the provided block as a distribution.
    #
    # If the block fails, the stat is still reported, then the error
    # is reraised
    #
    # @param [String] stat stat name.
    # @param [Numeric] value distribution value.
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Array<String>] :tags An array of tags
    # @example Report the time (in ms) taken to activate an account
    #   $statsd.distribution_time('account.activate') { @account.activate! }
    def distribution_time: [T] (String stat, Numeric sample_rate) { () -> T } -> T
                         | [T] (String stat, ?Hash[Symbol, untyped] opts) { () -> T } -> T

    # Sends a timing (in ms) for the given stat to the statsd server. The
    # sample_rate determines what percentage of the time this report is sent. The
    # statsd server then uses the sample_rate to correctly track the average
    # timing for the stat.
    #
    # @param [String] stat stat name
    # @param [Integer] ms timing in milliseconds
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    def timing: (String stat, Integer ms, Numeric sample_rate) -> void
              | (String stat, Integer ms, ?Hash[Symbol, untyped] opts) -> void

    # Reports execution time of the provided block using {#timing}.
    #
    # If the block fails, the stat is still reported, then the error
    # is reraised
    #
    # @param [String] stat stat name
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @yield The operation to be timed
    # @see #timing
    # @example Report the time (in ms) taken to activate an account
    #   $statsd.time('account.activate') { @account.activate! }
    def time: [T] (String stat, Numeric sample_rate) { () -> T } -> T
            | [T] (String stat, ?Hash[Symbol, untyped] opts) { () -> T } -> T

    # Sends a value to be tracked as a set to the statsd server.
    #
    # @param [String] stat stat name.
    # @param [Numeric] value set value.
    # @param [Hash] opts the options to create the metric with
    # @option opts [Numeric] :sample_rate sample rate, 1 for always
    # @option opts [Boolean] :pre_sampled If true, the client assumes the caller has already sampled metrics at :sample_rate, and doesn't perform sampling.
    # @option opts [Array<String>] :tags An array of tags
    # @example Record a unique visitory by id:
    #   $statsd.set('visitors.uniques', User.id)
    def set: (String stat, Numeric value, Numeric sample_rate) -> void
           | (String stat, Numeric value, ?Hash[Symbol, untyped] opts) -> void

    # This method allows you to send custom service check statuses.
    #
    # @param [String] name Service check name
    # @param [String] status Service check status.
    # @param [Hash] opts the additional data about the service check
    # @option opts [Integer, String, nil] :timestamp (nil) Assign a timestamp to the service check. Default is now when none
    # @option opts [String, nil] :hostname (nil) Assign a hostname to the service check.
    # @option opts [Array<String>, nil] :tags (nil) An array of tags
    # @option opts [String, nil] :message (nil) A message to associate with this service check status
    # @example Report a critical service check status
    #   $statsd.service_check('my.service.check', Statsd::CRITICAL, :tags=>['urgent'])
    def service_check: (String name, String status, ?Hash[Symbol, untyped] opts) -> void

    # This end point allows you to post events to the stream. You can tag them, set priority and even aggregate them with other events.
    #
    # Aggregation in the stream is made on hostname/event_type/source_type/aggregation_key.
    # If there's no event type, for example, then that won't matter;
    # it will be grouped with other events that don't have an event type.
    #
    # @param [String] title Event title
    # @param [String] text Event text. Supports newlines (+\n+)
    # @param [Hash] opts the additional data about the event
    # @option opts [Integer, String, nil] :date_happened (nil) Assign a timestamp to the event. Default is now when none
    # @option opts [String, nil] :hostname (nil) Assign a hostname to the event.
    # @option opts [String, nil] :aggregation_key (nil) Assign an aggregation key to the event, to group it with some others
    # @option opts [String, nil] :priority ('normal') Can be "normal" or "low"
    # @option opts [String, nil] :source_type_name (nil) Assign a source type to the event
    # @option opts [String, nil] :alert_type ('info') Can be "error", "warning", "info" or "success".
    # @option opts [Boolean, false] :truncate_if_too_long (false) Truncate the event if it is too long
    # @option opts [Array<String>] :tags tags to be added to every metric
    # @example Report an awful event:
    #   $statsd.event('Something terrible happened', 'The end is near if we do nothing', :alert_type=>'warning', :tags=>['end_of_times','urgent'])
    def event: (String title, String text, ?Hash[Symbol, untyped] opts) -> void

    # Send several metrics in the same packet.
    # They will be buffered and flushed when the block finishes.
    #
    # This method exists for compatibility with v4.x versions, it is not needed
    # anymore since the batching is now automatically done internally.
    # It also means that an automatic flush could occur if the buffer is filled
    # during the execution of the batch block.
    #
    # This method is DEPRECATED and will be removed in future v6.x API.
    #
    # @example Send several metrics in one packet:
    #   $statsd.batch do |s|
    #      s.gauge('users.online',156)
    #      s.increment('page.views')
    #    end
    def batch: () { (self) -> void } -> void

    # Close the underlying socket
    #
    # @param [Boolean, true] flush Should we flush the metrics before closing
    def close: (?flush: bool) -> void

    def sync_with_outbound_io: () -> untyped

    # Flush the buffer into the connection
    def flush: (?flush_telemetry: bool, ?sync: bool) -> void

    def telemetry: () -> untyped

    def host: () -> String?

    def port: () -> Integer?

    def socket_path: () -> String?

    def transport_type: () -> untyped
  end
end

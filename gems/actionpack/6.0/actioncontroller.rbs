module ActionController
  interface _API_and_Base
    def flash: () -> untyped
  end

  class Base < Metal
    include _API_and_Base

    # https://github.com/rails/rails/blob/v6.0.3.2/actionpack/lib/action_controller/base.rb#L205-L255
    include AbstractController::Rendering
    include AbstractController::Translation
    include AbstractController::AssetPaths
    include Helpers
    extend Helpers::ClassMethods
    extend AbstractController::Helpers::ClassMethods
    include UrlFor
    include Redirecting
    include ActionView::Layouts
    extend ::ActionView::Layouts::ClassMethods
    include Rendering
    extend Rendering::ClassMethods
    include Renderers::All
    include ConditionalGet
    extend ConditionalGet::ClassMethods
    include EtagWithTemplateDigest
    include EtagWithFlash
    include Caching
    extend AbstractController::Caching::ClassMethods
    extend AbstractController::Caching::Fragments::ClassMethods
    include MimeResponds
    include ImplicitRender
    include StrongParameters
    include ParameterEncoding
    extend ParameterEncoding::ClassMethods
    include Cookies
    include Flash
    extend Flash::ClassMethods
    include FormBuilder
    extend FormBuilder::ClassMethods
    include RequestForgeryProtection
    extend RequestForgeryProtection::ClassMethods
    include ContentSecurityPolicy
    extend ContentSecurityPolicy::ClassMethods
    include ForceSSL
    extend ForceSSL::ClassMethods
    include Streaming
    include DataStreaming
    include HttpAuthentication::Basic::ControllerMethods
    extend HttpAuthentication::Basic::ControllerMethods::ClassMethods
    include HttpAuthentication::Digest::ControllerMethods
    include HttpAuthentication::Token::ControllerMethods
    include DefaultHeaders
    extend DefaultHeaders::ClassMethods
    include AbstractController::Callbacks
    extend AbstractController::Callbacks::ClassMethods
    include Rescue
    include ActiveSupport::Rescuable
    extend ActiveSupport::Rescuable::ClassMethods
    include Instrumentation
    extend Instrumentation::ClassMethods
    include ParamsWrapper
    extend ParamsWrapper::ClassMethods
  end

  class API < Metal
    include _API_and_Base

    # https://github.com/rails/rails/blob/v6.0.3.2/actionpack/lib/action_controller/api.rb#L112-L145
    include AbstractController::Rendering
    include UrlFor
    include Redirecting
    include ApiRendering
    include Renderers::All
    include ConditionalGet
    extend ConditionalGet::ClassMethods
    include BasicImplicitRender
    include StrongParameters
    include ForceSSL
    extend ForceSSL::ClassMethods
    include DataStreaming
    include DefaultHeaders
    extend DefaultHeaders::ClassMethods
    include AbstractController::Callbacks
    extend AbstractController::Callbacks::ClassMethods
    include Rescue
    include ActiveSupport::Rescuable
    extend ActiveSupport::Rescuable::ClassMethods
    include Instrumentation
    extend Instrumentation::ClassMethods
    include ParamsWrapper
    extend ParamsWrapper::ClassMethods
  end

  module HttpAuthentication
    module Token
      TOKEN_KEY: ::String
      TOKEN_REGEX: ::Regexp
      AUTHN_PAIR_DELIMITERS: ::Regexp

      extend ::ActionController::HttpAuthentication::Token

      module ControllerMethods
        def authenticate_or_request_with_http_token: (?String realm, ?String? message) { (String token, ActiveSupport::HashWithIndifferentAccess[untyped, untyped] options) -> boolish } -> untyped

        def authenticate_with_http_token: () { (String token, ActiveSupport::HashWithIndifferentAccess[untyped, untyped] options) -> boolish } -> boolish

        def request_http_token_authentication: (?String realm, ?String? message) -> void
      end

      def authenticate: (instance controller) { (String token, ActiveSupport::HashWithIndifferentAccess[untyped, untyped] options) -> boolish } -> boolish

      def token_and_options: (ActionDispatch::Request request) -> [String, ActiveSupport::HashWithIndifferentAccess[untyped, untyped]]?

      def token_params_from: (String auth) -> Array[String]

      def raw_params: (String auth) -> Array[String]

      def params_array_from: (Array[String] raw_params) -> Array[String]

      def rewrite_param_values: (Array[String] array_params) -> Array[String]

      def encode_credentials: (String token, ?::Hash[untyped, untyped] options) -> ::String

      def authentication_request: (instance controller, String realm, ?String? message) -> void
    end
  end
end

module AbstractController::Callbacks::ClassMethods
  interface _BeforeActionCallback
    def before: (ActionController::Base controller) -> void
  end

  interface _AroundActionCallback
    def around: (ActionController::Base controller) { () -> void } -> void
  end

  interface _AfterActionCallback
    def after: (ActionController::Base controller) -> void
  end

  type before_action_callback[T] = Symbol | ^(T controller) [self: T] -> void | _BeforeActionCallback
  type around_action_callback[T] = Symbol | ^(T controller, ^() -> void) [self: T] -> void | _AroundActionCallback
  type after_action_callback[T] = Symbol | ^(T controller) [self: T] -> void | _AfterActionCallback

  def before_action: (*before_action_callback[instance], ?if: before_action_callback[instance], ?unless: before_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void
  def around_action: (*around_action_callback[instance], ?if: around_action_callback[instance], ?unless: around_action_callback[instance], **untyped) ?{ (instance controller,  ^() -> void) [self: instance] -> void } -> void
  def after_action: (*after_action_callback[instance], ?if: after_action_callback[instance], ?unless: after_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void
  def skip_before_action: (*before_action_callback[instance], ?if: before_action_callback[instance], ?unless: before_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void
  def skip_around_action: (*around_action_callback[instance], ?if: around_action_callback[instance], ?unless: around_action_callback[instance], **untyped) ?{ (instance controller,  ^() -> void) [self: instance] -> void } -> void
  def skip_after_action: (*after_action_callback[instance], ?if: after_action_callback[instance], ?unless: after_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void
  def prepend_before_action: (*before_action_callback[instance], ?if: before_action_callback[instance], ?unless: before_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void
  def prepend_around_action: (*around_action_callback[instance], ?if: around_action_callback[instance], ?unless: around_action_callback[instance], **untyped) ?{ (instance controller,  ^() -> void) [self: instance] -> void } -> void
  def prepend_after_action: (*after_action_callback[instance], ?if: after_action_callback[instance], ?unless: after_action_callback[instance], **untyped) ?{ (instance controller) [self: instance] -> void } -> void

  alias append_before_action before_action
  alias append_around_action around_action
  alias append_after_action after_action
end

module ActionController
  class Parameters
    def keys: () -> Array[untyped]
    def key?: () -> bool
    def has_key?: () -> bool
    def values: () -> Array[untyped]
    def has_value?: () -> bool
    def empty?: () -> bool
    def include?: (untyped) -> bool
    def as_json: () -> String
    def to_s: () -> String
    def each_key: () { (untyped) -> untyped} -> Hash[untyped, untyped]
                | () -> Enumerator[untyped, self]
    def fetch: (untyped key, *untyped args) ?{ () -> untyped } -> untyped
  end
end

module AbstractController
  module Helpers
    extend ActiveSupport::Concern

    class MissingHelperError < LoadError
      def initialize: (untyped error, untyped path) -> untyped
    end

    module ClassMethods
      # When a class is inherited, wrap its helper module in a new module.
      # This ensures that the parent class's module can be changed
      # independently of the child class's.
      def inherited: (untyped klass) -> untyped

      # Declare a controller method as a helper. For example, the following
      # makes the +current_user+ and +logged_in?+ controller methods available
      # to the view:
      #   class ApplicationController < ActionController::Base
      #     helper_method :current_user, :logged_in?
      #
      #     def current_user
      #       @current_user ||= User.find_by(id: session[:user])
      #     end
      #
      #     def logged_in?
      #       current_user != nil
      #     end
      #   end
      #
      # In a view:
      #  <% if logged_in? -%>Welcome, <%= current_user.name %><% end -%>
      #
      # ==== Parameters
      # * <tt>method[, method]</tt> - A name or names of a method on the controller
      #   to be made available on the view.
      def helper_method: (*untyped meths) -> untyped

      # The +helper+ class method can take a series of helper module names, a block, or both.
      #
      # ==== Options
      # * <tt>*args</tt> - Module, Symbol, String
      # * <tt>block</tt> - A block defining helper methods
      #
      # When the argument is a module it will be included directly in the template class.
      #   helper FooHelper # => includes FooHelper
      #
      # When the argument is a string or symbol, the method will provide the "_helper" suffix, require the file
      # and include the module in the template class. The second form illustrates how to include custom helpers
      # when working with namespaced controllers, or other cases where the file containing the helper definition is not
      # in one of Rails' standard load paths:
      #   helper :foo             # => requires 'foo_helper' and includes FooHelper
      #   helper 'resources/foo'  # => requires 'resources/foo_helper' and includes Resources::FooHelper
      #
      # Additionally, the +helper+ class method can receive and evaluate a block, making the methods defined available
      # to the template.
      #
      #   # One line
      #   helper { def hello() "Hello, world!" end }
      #
      #   # Multi-line
      #   helper do
      #     def foo(bar)
      #       "#{bar} is the very best"
      #     end
      #   end
      #
      # Finally, all the above styles can be mixed together, and the +helper+ method can be invoked with a mix of
      # +symbols+, +strings+, +modules+ and blocks.
      #
      #   helper(:three, BlindHelper) { def mice() 'mice' end }
      #
      def helper: (*untyped args) ?{ () -> untyped } -> untyped

      # Clears up all existing helpers in this class, only keeping the helper
      # with the same name as this class.
      def clear_helpers: () -> untyped

      # Returns a list of modules, normalized from the acceptable kinds of
      # helpers with the following behavior:
      #
      # String or Symbol:: :FooBar or "FooBar" becomes "foo_bar_helper",
      # and "foo_bar_helper.rb" is loaded using require_dependency.
      #
      # Module:: No further processing
      #
      # After loading the appropriate files, the corresponding modules
      # are returned.
      #
      # ==== Parameters
      # * <tt>args</tt> - An array of helpers
      #
      # ==== Returns
      # * <tt>Array</tt> - A normalized list of modules for the list of
      #   helpers provided.
      def modules_for_helpers: (untyped args) -> untyped

      private

      # Makes all the (instance) methods in the helper module available to templates
      # rendered through this controller.
      #
      # ==== Parameters
      # * <tt>module</tt> - The module to include into the current helper module
      #   for the class
      def add_template_helper: (untyped mod) -> untyped

      def default_helper_module!: () -> untyped
    end
  end
end

module AbstractController
  module Caching
    # Fragment caching is used for caching various blocks within
    # views without caching the entire action as a whole. This is
    # useful when certain elements of an action change frequently or
    # depend on complicated state while other parts rarely change or
    # can be shared amongst multiple parties. The caching is done using
    # the +cache+ helper available in the Action View. See
    # ActionView::Helpers::CacheHelper for more information.
    #
    # While it's strongly recommended that you use key-based cache
    # expiration (see links in CacheHelper for more information),
    # it is also possible to manually expire caches. For example:
    #
    #   expire_fragment('name_of_cache')
    module Fragments
      extend ActiveSupport::Concern

      module ClassMethods
        # Allows you to specify controller-wide key prefixes for
        # cache fragments. Pass either a constant +value+, or a block
        # which computes a value each time a cache key is generated.
        #
        # For example, you may want to prefix all fragment cache keys
        # with a global version identifier, so you can easily
        # invalidate all caches.
        #
        #   class ApplicationController
        #     fragment_cache_key "v1"
        #   end
        #
        # When it's time to invalidate all fragments, simply change
        # the string constant. Or, progressively roll out the cache
        # invalidation using a computed value:
        #
        #   class ApplicationController
        #     fragment_cache_key do
        #       @account.id.odd? ? "v1" : "v2"
        #     end
        #   end
        def fragment_cache_key: (?untyped? value) ?{ () -> untyped } -> untyped
      end

      # Given a key (as described in +expire_fragment+), returns
      # a key array suitable for use in reading, writing, or expiring a
      # cached fragment. All keys begin with <tt>:views</tt>,
      # followed by <tt>ENV["RAILS_CACHE_ID"]</tt> or <tt>ENV["RAILS_APP_VERSION"]</tt> if set,
      # followed by any controller-wide key prefix values, ending
      # with the specified +key+ value.
      def combined_fragment_cache_key: (untyped key) -> untyped

      # Writes +content+ to the location signified by
      # +key+ (see +expire_fragment+ for acceptable formats).
      def write_fragment: (untyped key, untyped content, ?untyped? options) -> untyped

      # Reads a cached fragment from the location signified by +key+
      # (see +expire_fragment+ for acceptable formats).
      def read_fragment: (untyped key, ?untyped? options) -> (nil | untyped)

      # Check if a cached fragment from the location signified by
      # +key+ exists (see +expire_fragment+ for acceptable formats).
      def fragment_exist?: (untyped key, ?untyped? options) -> (nil | untyped)

      # Removes fragments from the cache.
      #
      # +key+ can take one of three forms:
      #
      # * String - This would normally take the form of a path, like
      #   <tt>pages/45/notes</tt>.
      # * Hash - Treated as an implicit call to +url_for+, like
      #   <tt>{ controller: 'pages', action: 'notes', id: 45}</tt>
      # * Regexp - Will remove any fragment that matches, so
      #   <tt>%r{pages/\d*/notes}</tt> might remove all notes. Make sure you
      #   don't use anchors in the regex (<tt>^</tt> or <tt>$</tt>) because
      #   the actual filename matched looks like
      #   <tt>./cache/filename/path.cache</tt>. Note: Regexp expiration is
      #   only supported on caches that can iterate over all keys (unlike
      #   memcached).
      #
      # +options+ is passed through to the cache store's +delete+
      # method (or <tt>delete_matched</tt>, for Regexp keys).
      def expire_fragment: (untyped key, ?untyped? options) -> (nil | untyped)

      def instrument_fragment_cache: (untyped name, untyped key) { () -> untyped } -> untyped
    end
  end
end

module AbstractController
  module Caching
    extend ActiveSupport::Concern

    extend ActiveSupport::Autoload

    module ConfigMethods
      def cache_store: () -> untyped

      def cache_store=: (untyped store) -> untyped

      private

      def cache_configured?: () -> untyped
    end

    include ConfigMethods

    include AbstractController::Caching::Fragments
    extend AbstractController::Caching::Fragments::ClassMethods

    extend ConfigMethods

    module ClassMethods
      def view_cache_dependency: () { () -> untyped } -> untyped
    end

    def view_cache_dependencies: () -> untyped

    private

    def cache: (untyped key, ?::Hash[untyped, untyped] options) { () -> untyped } -> untyped
  end
end

module ActionController
  # \Caching is a cheap way of speeding up slow applications by keeping the result of
  # calculations, renderings, and database calls around for subsequent requests.
  #
  # You can read more about each approach by clicking the modules below.
  #
  # Note: To turn off all caching provided by Action Controller, set
  #   config.action_controller.perform_caching = false
  #
  # == \Caching stores
  #
  # All the caching stores from ActiveSupport::Cache are available to be used as backends
  # for Action Controller caching.
  #
  # Configuration examples (FileStore is the default):
  #
  #   config.action_controller.cache_store = :memory_store
  #   config.action_controller.cache_store = :file_store, '/path/to/cache/directory'
  #   config.action_controller.cache_store = :mem_cache_store, 'localhost'
  #   config.action_controller.cache_store = :mem_cache_store, Memcached::Rails.new('localhost:11211')
  #   config.action_controller.cache_store = MyOwnStore.new('parameter')
  module Caching
    extend ActiveSupport::Autoload

    extend ActiveSupport::Concern

    include AbstractController::Caching
    extend AbstractController::Caching::ClassMethods
    extend AbstractController::Caching::Fragments::ClassMethods

    private

    def instrument_payload: (untyped key) -> { controller: untyped, action: untyped, key: untyped }

    def instrument_name: () -> "action_controller"
  end
end

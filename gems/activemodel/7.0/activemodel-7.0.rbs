module ActiveModel
  # == Active \Model \Errors
  #
  # Provides error related functionalities you can include in your object
  # for handling error messages and interacting with Action View helpers.
  #
  # A minimal implementation could be:
  #
  #   class Person
  #     # Required dependency for ActiveModel::Errors
  #     extend ActiveModel::Naming
  #
  #     def initialize
  #       @errors = ActiveModel::Errors.new(self)
  #     end
  #
  #     attr_accessor :name
  #     attr_reader   :errors
  #
  #     def validate!
  #       errors.add(:name, :blank, message: "cannot be nil") if name.nil?
  #     end
  #
  #     # The following methods are needed to be minimally implemented
  #
  #     def read_attribute_for_validation(attr)
  #       send(attr)
  #     end
  #
  #     def self.human_attribute_name(attr, options = {})
  #       attr
  #     end
  #
  #     def self.lookup_ancestors
  #       [self]
  #     end
  #   end
  #
  # The last three methods are required in your object for +Errors+ to be
  # able to generate error messages correctly and also handle multiple
  # languages. Of course, if you extend your object with ActiveModel::Translation
  # you will not need to implement the last two. Likewise, using
  # ActiveModel::Validations will handle the validation related methods
  # for you.
  #
  # The above allows you to do:
  #
  #   person = Person.new
  #   person.validate!            # => ["cannot be nil"]
  #   person.errors.full_messages # => ["name cannot be nil"]
  #   # etc..
  class Errors
    @base: untyped

    @errors: untyped

    include Enumerable

    extend Forwardable

    # The actual array of +Error+ objects
    # This method is aliased to <tt>objects</tt>.
    attr_reader errors: untyped

    alias objects errors

    # Pass in the instance of the object that is using the errors object.
    #
    #   class Person
    #     def initialize
    #       @errors = ActiveModel::Errors.new(self)
    #     end
    #   end
    def initialize: (untyped base) -> void

    def initialize_dup: (untyped other) -> untyped

    # Copies the errors from <tt>other</tt>.
    # For copying errors but keep <tt>@base</tt> as is.
    #
    # ==== Parameters
    #
    # * +other+ - The ActiveModel::Errors instance.
    #
    # ==== Examples
    #
    #   person.errors.copy!(other)
    #
    def copy!: (untyped other) -> untyped

    # Imports one error.
    # Imported errors are wrapped as a NestedError,
    # providing access to original error object.
    # If attribute or type needs to be overridden, use +override_options+.
    #
    # ==== Options
    #
    # * +:attribute+ - Override the attribute the error belongs to.
    # * +:type+ - Override type of the error.
    def import: (untyped error, ?::Hash[untyped, untyped] override_options) -> untyped

    # Merges the errors from <tt>other</tt>,
    # each Error wrapped as NestedError.
    #
    # ==== Parameters
    #
    # * +other+ - The ActiveModel::Errors instance.
    #
    # ==== Examples
    #
    #   person.errors.merge!(other)
    #
    def merge!: (untyped other) -> untyped

    # Search for errors matching +attribute+, +type+, or +options+.
    #
    # Only supplied params will be matched.
    #
    #   person.errors.where(:name) # => all name errors.
    #   person.errors.where(:name, :too_short) # => all name errors being too short
    #   person.errors.where(:name, :too_short, minimum: 2) # => all name errors being too short and minimum is 2
    def where: (untyped attribute, ?untyped? type, **untyped options) -> untyped

    # Returns +true+ if the error messages include an error for the given key
    # +attribute+, +false+ otherwise.
    #
    #   person.errors.messages        # => {:name=>["cannot be nil"]}
    #   person.errors.include?(:name) # => true
    #   person.errors.include?(:age)  # => false
    def include?: (untyped attribute) -> untyped

    alias has_key? include?

    alias key? include?

    # Delete messages for +key+. Returns the deleted messages.
    #
    #   person.errors[:name]        # => ["cannot be nil"]
    #   person.errors.delete(:name) # => ["cannot be nil"]
    #   person.errors[:name]        # => []
    def delete: (untyped attribute, ?untyped? type, **untyped options) -> untyped

    # When passed a symbol or a name of a method, returns an array of errors
    # for the method.
    #
    #   person.errors[:name]  # => ["cannot be nil"]
    #   person.errors['name'] # => ["cannot be nil"]
    def []: (untyped attribute) -> untyped

    # Returns all error attribute names
    #
    #   person.errors.messages        # => {:name=>["cannot be nil", "must be specified"]}
    #   person.errors.attribute_names # => [:name]
    def attribute_names: () -> untyped

    # Returns a Hash that can be used as the JSON representation for this
    # object. You can pass the <tt>:full_messages</tt> option. This determines
    # if the json object should contain full messages or not (false by default).
    #
    #   person.errors.as_json                      # => {:name=>["cannot be nil"]}
    #   person.errors.as_json(full_messages: true) # => {:name=>["name cannot be nil"]}
    def as_json: (?untyped? options) -> untyped

    # Returns a Hash of attributes with their error messages. If +full_messages+
    # is +true+, it will contain full messages (see +full_message+).
    #
    #   person.errors.to_hash       # => {:name=>["cannot be nil"]}
    #   person.errors.to_hash(true) # => {:name=>["name cannot be nil"]}
    def to_hash: (?bool full_messages) -> untyped

    EMPTY_ARRAY: ::Array[untyped]

    # Returns a Hash of attributes with an array of their error messages.
    def messages: () -> untyped

    # Returns a Hash of attributes with an array of their error details.
    def details: () -> untyped

    # Returns a Hash of attributes with an array of their Error objects.
    #
    #   person.errors.group_by_attribute
    #   # => {:name=>[<#ActiveModel::Error>, <#ActiveModel::Error>]}
    def group_by_attribute: () -> untyped

    # Adds a new error of +type+ on +attribute+.
    # More than one error can be added to the same +attribute+.
    # If no +type+ is supplied, <tt>:invalid</tt> is assumed.
    #
    #   person.errors.add(:name)
    #   # Adds <#ActiveModel::Error attribute=name, type=invalid>
    #   person.errors.add(:name, :not_implemented, message: "must be implemented")
    #   # Adds <#ActiveModel::Error attribute=name, type=not_implemented,
    #                               options={:message=>"must be implemented"}>
    #
    #   person.errors.messages
    #   # => {:name=>["is invalid", "must be implemented"]}
    #
    # If +type+ is a string, it will be used as error message.
    #
    # If +type+ is a symbol, it will be translated using the appropriate
    # scope (see +generate_message+).
    #
    #   person.errors.add(:name, :blank)
    #   person.errors.messages
    #   # => {:name=>["can't be blank"]}
    #
    #   person.errors.add(:name, :too_long, { count: 25 })
    #   person.errors.messages
    #   # => ["is too long (maximum is 25 characters)"]
    #
    # If +type+ is a proc, it will be called, allowing for things like
    # <tt>Time.now</tt> to be used within an error.
    #
    # If the <tt>:strict</tt> option is set to +true+, it will raise
    # ActiveModel::StrictValidationFailed instead of adding the error.
    # <tt>:strict</tt> option can also be set to any other exception.
    #
    #   person.errors.add(:name, :invalid, strict: true)
    #   # => ActiveModel::StrictValidationFailed: Name is invalid
    #   person.errors.add(:name, :invalid, strict: NameIsInvalid)
    #   # => NameIsInvalid: Name is invalid
    #
    #   person.errors.messages # => {}
    #
    # +attribute+ should be set to <tt>:base</tt> if the error is not
    # directly associated with a single attribute.
    #
    #   person.errors.add(:base, :name_or_email_blank,
    #     message: "either name or email must be present")
    #   person.errors.messages
    #   # => {:base=>["either name or email must be present"]}
    #   person.errors.details
    #   # => {:base=>[{error: :name_or_email_blank}]}
    def add: (untyped attribute, ?::Symbol type, **untyped options) -> untyped

    # Returns +true+ if an error matches provided +attribute+ and +type+,
    # or +false+ otherwise. +type+ is treated the same as for +add+.
    #
    #   person.errors.add :name, :blank
    #   person.errors.added? :name, :blank           # => true
    #   person.errors.added? :name, "can't be blank" # => true
    #
    # If the error requires options, then it returns +true+ with
    # the correct options, or +false+ with incorrect or missing options.
    #
    #   person.errors.add :name, :too_long, { count: 25 }
    #   person.errors.added? :name, :too_long, count: 25                     # => true
    #   person.errors.added? :name, "is too long (maximum is 25 characters)" # => true
    #   person.errors.added? :name, :too_long, count: 24                     # => false
    #   person.errors.added? :name, :too_long                                # => false
    #   person.errors.added? :name, "is too long"                            # => false
    def added?: (untyped attribute, ?::Symbol type, ?::Hash[untyped, untyped] options) -> untyped

    # Returns +true+ if an error on the attribute with the given type is
    # present, or +false+ otherwise. +type+ is treated the same as for +add+.
    #
    #   person.errors.add :age
    #   person.errors.add :name, :too_long, { count: 25 }
    #   person.errors.of_kind? :age                                            # => true
    #   person.errors.of_kind? :name                                           # => false
    #   person.errors.of_kind? :name, :too_long                                # => true
    #   person.errors.of_kind? :name, "is too long (maximum is 25 characters)" # => true
    #   person.errors.of_kind? :name, :not_too_long                            # => false
    #   person.errors.of_kind? :name, "is too long"                            # => false
    def of_kind?: (untyped attribute, ?::Symbol type) -> untyped

    # Returns all the full error messages in an array.
    #
    #   class Person
    #     validates_presence_of :name, :address, :email
    #     validates_length_of :name, in: 5..30
    #   end
    #
    #   person = Person.create(address: '123 First St.')
    #   person.errors.full_messages
    #   # => ["Name is too short (minimum is 5 characters)", "Name can't be blank", "Email can't be blank"]
    def full_messages: () -> untyped

    alias to_a full_messages

    # Returns all the full error messages for a given attribute in an array.
    #
    #   class Person
    #     validates_presence_of :name, :email
    #     validates_length_of :name, in: 5..30
    #   end
    #
    #   person = Person.create()
    #   person.errors.full_messages_for(:name)
    #   # => ["Name is too short (minimum is 5 characters)", "Name can't be blank"]
    def full_messages_for: (untyped attribute) -> untyped

    # Returns all the error messages for a given attribute in an array.
    #
    #   class Person
    #     validates_presence_of :name, :email
    #     validates_length_of :name, in: 5..30
    #   end
    #
    #   person = Person.create()
    #   person.errors.messages_for(:name)
    #   # => ["is too short (minimum is 5 characters)", "can't be blank"]
    def messages_for: (untyped attribute) -> untyped

    # Returns a full message for a given attribute.
    #
    #   person.errors.full_message(:name, 'is invalid') # => "Name is invalid"
    def full_message: (untyped attribute, untyped message) -> untyped

    # Translates an error message in its default scope
    # (<tt>activemodel.errors.messages</tt>).
    #
    # Error messages are first looked up in <tt>activemodel.errors.models.MODEL.attributes.ATTRIBUTE.MESSAGE</tt>,
    # if it's not there, it's looked up in <tt>activemodel.errors.models.MODEL.MESSAGE</tt> and if
    # that is not there also, it returns the translation of the default message
    # (e.g. <tt>activemodel.errors.messages.MESSAGE</tt>). The translated model
    # name, translated attribute name, and the value are available for
    # interpolation.
    #
    # When using inheritance in your models, it will check all the inherited
    # models too, but only if the model itself hasn't been found. Say you have
    # <tt>class Admin < User; end</tt> and you wanted the translation for
    # the <tt>:blank</tt> error message for the <tt>title</tt> attribute,
    # it looks for these translations:
    #
    # * <tt>activemodel.errors.models.admin.attributes.title.blank</tt>
    # * <tt>activemodel.errors.models.admin.blank</tt>
    # * <tt>activemodel.errors.models.user.attributes.title.blank</tt>
    # * <tt>activemodel.errors.models.user.blank</tt>
    # * any default you provided through the +options+ hash (in the <tt>activemodel.errors</tt> scope)
    # * <tt>activemodel.errors.messages.blank</tt>
    # * <tt>errors.attributes.title.blank</tt>
    # * <tt>errors.messages.blank</tt>
    def generate_message: (untyped attribute, ?::Symbol type, ?::Hash[untyped, untyped] options) -> untyped

    def inspect: () -> ::String

    private

    def normalize_arguments: (untyped attribute, untyped type, **untyped options) -> ::Array[untyped]
  end

  # Raised when a validation cannot be corrected by end users and are considered
  # exceptional.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #
  #     validates_presence_of :name, strict: true
  #   end
  #
  #   person = Person.new
  #   person.name = nil
  #   person.valid?
  #   # => ActiveModel::StrictValidationFailed: Name can't be blank
  class StrictValidationFailed < StandardError
  end

  # Raised when attribute values are out of range.
  class RangeError < ::RangeError
  end

  # Raised when unknown attributes are supplied via mass assignment.
  #
  #   class Person
  #     include ActiveModel::AttributeAssignment
  #     include ActiveModel::Validations
  #   end
  #
  #   person = Person.new
  #   person.assign_attributes(name: 'Gorby')
  #   # => ActiveModel::UnknownAttributeError: unknown attribute 'name' for Person.
  class UnknownAttributeError < NoMethodError
    @record: untyped

    @attribute: untyped

    attr_reader record: untyped

    attr_reader attribute: untyped

    def initialize: (untyped record, untyped attribute) -> void
  end
end

module ActiveModel
  # == Active \Model \Error
  #
  # Represents one single error
  class Error
    @base: untyped

    @attribute: untyped

    @raw_type: untyped

    @type: untyped

    @options: untyped

    CALLBACKS_OPTIONS: ::Array[:if | :unless | :on | :allow_nil | :allow_blank | :strict]

    MESSAGE_OPTIONS: ::Array[:message]

    def self.full_message: (untyped attribute, untyped message, untyped base) -> untyped

    def self.generate_message: (untyped attribute, untyped type, untyped base, untyped options) -> untyped

    def initialize: (untyped base, untyped attribute, ?::Symbol type, **untyped options) -> void

    def initialize_dup: (untyped other) -> untyped

    # The object which the error belongs to
    attr_reader base: untyped

    # The attribute of +base+ which the error belongs to
    attr_reader attribute: untyped

    # The type of error, defaults to +:invalid+ unless specified
    attr_reader type: untyped

    # The raw value provided as the second parameter when calling +errors#add+
    attr_reader raw_type: untyped

    # The options provided when calling +errors#add+
    attr_reader options: untyped

    # Returns the error message.
    #
    #   error = ActiveModel::Error.new(person, :name, :too_short, count: 5)
    #   error.message
    #   # => "is too short (minimum is 5 characters)"
    def message: () -> untyped

    # Returns the error details.
    #
    #   error = ActiveModel::Error.new(person, :name, :too_short, count: 5)
    #   error.details
    #   # => { error: :too_short, count: 5 }
    def details: () -> untyped

    alias detail details

    # Returns the full error message.
    #
    #   error = ActiveModel::Error.new(person, :name, :too_short, count: 5)
    #   error.full_message
    #   # => "Name is too short (minimum is 5 characters)"
    def full_message: () -> untyped

    # See if error matches provided +attribute+, +type+, and +options+.
    #
    # Omitted params are not checked for a match.
    def match?: (untyped attribute, ?untyped? type, **untyped options) -> (false | true)

    # See if error matches provided +attribute+, +type+, and +options+ exactly.
    #
    # All params must be equal to Error's own attributes to be considered a
    # strict match.
    def strict_match?: (untyped attribute, untyped type, **untyped options) -> (false | untyped)

    def ==: (untyped other) -> untyped

    alias eql? ==

    def hash: () -> untyped

    def inspect: () -> ::String

    def attributes_for_hash: () -> ::Array[untyped]
  end
end

# !!! GENERATED FILE !!!
# Please see generators/yard-generator/README.md

# Handlers are pluggable semantic parsers for YARD's code generation
# phase. They allow developers to control what information gets
# generated by YARD, giving them the ability to, for instance, document
# any Ruby DSLs that a customized framework may use. A good example
# of this would be the ability to document and generate meta data for
# the 'describe' declaration of the RSpec testing framework by simply
# adding a handler for such a keyword. Similarly, any Ruby API that
# takes advantage of class level declarations could add these to the
# documentation in a very explicit format by treating them as first-
# class objects in any outputted documentation.
#
# == Overview of a Typical Handler Scenario
#
# Generally, a handler class will declare a set of statements which
# it will handle using the {handles} class declaration. It will then
# implement the {#process} method to do the work. The processing would
# usually involve the manipulation of the {#namespace}, {#owner}
# {CodeObjects::Base code objects} or the creation of new ones, in
# which case they should be registered by {#register}, a method that
# sets some basic attributes for the new objects.
#
# Handlers are usually simple and take up to a page of code to process
# and register a new object or add new attributes to the current +namespace+.
#
# == Setting up a Handler for Use
#
# A Handler is automatically registered when it is subclassed from the
# base class. The only other thing that needs to be done is to specify
# which statement the handler will process. This is done with the +handles+
# declaration, taking either a {Parser::Ruby::Legacy::RubyToken}, {String} or `Regexp`.
# Here is a simple example which processes module statements.
#
#   class MyModuleHandler < YARD::Handlers::Base
#     handles TkMODULE
#
#     def process
#       # do something
#     end
#   end
#
# == Processing Handler Data
#
# The goal of a specific handler is really up to the developer, and as
# such there is no real guideline on how to process the data. However,
# it is important to know where the data is coming from to be able to use
# it.
#
# === +statement+ Attribute
#
# The +statement+ attribute pertains to the {Parser::Ruby::Legacy::Statement} object
# containing a set of tokens parsed in by the parser. This is the main set
# of data to be analyzed and processed. The comments attached to the statement
# can be accessed by the {Parser::Ruby::Legacy::Statement#comments} method, but generally
# the data to be processed will live in the +tokens+ attribute. This list
# can be converted to a +String+ using +#to_s+ to parse the data with
# regular expressions (or other text processing mechanisms), if needed.
#
# === +namespace+ Attribute
#
# The +namespace+ attribute is a {CodeObjects::NamespaceObject namespace object}
# which represents the current namespace that the parser is in. For instance:
#
#   module SomeModule
#     class MyClass
#       def mymethod; end
#     end
#   end
#
# If a handler was to parse the 'class MyClass' statement, it would
# be necessary to know that it belonged inside the SomeModule module.
# This is the value that +namespace+ would return when processing such
# a statement. If the class was then entered and another handler was
# called on the method, the +namespace+ would be set to the 'MyClass'
# code object.
#
# === +owner+ Attribute
#
# The +owner+ attribute is similar to the +namespace+ attribute in that
# it also follows the scope of the code during parsing. However, a namespace
# object is loosely defined as a module or class and YARD has the ability
# to parse beyond module and class blocks (inside methods, for instance),
# so the +owner+ attribute would not be limited to modules and classes.
#
# To put this into context, the example from above will be used. If a method
# handler was added to the mix and decided to parse inside the method body,
# the +owner+ would be set to the method object but the namespace would remain
# set to the class. This would allow the developer to process any method
# definitions set inside a method (def x; def y; 2 end end) by adding them
# to the correct namespace (the class, not the method).
#
# In summary, the distinction between +namespace+ and +owner+ can be thought
# of as the difference between first-class Ruby objects (namespaces) and
# second-class Ruby objects (methods).
#
# === +visibility+ and +scope+ Attributes
#
# Mainly needed for parsing methods, the +visibility+ and +scope+ attributes
# refer to the public/protected/private and class/instance values (respectively)
# of the current parsing position.
#
# == Parsing Blocks in Statements
#
# In addition to parsing a statement and creating new objects, some
# handlers may wish to continue parsing the code inside the statement's
# block (if there is one). In this context, a block means the inside
# of any statement, be it class definition, module definition, if
# statement or classic 'Ruby block'.
#
# For example, a class statement would be "class MyClass" and the block
# would be a list of statements including the method definitions inside
# the class. For a class handler, the programmer would execute the
# {#parse_block} method to continue parsing code inside the block, with
# the +namespace+ now pointing to the class object the handler created.
#
# YARD has the ability to continue into any block: class, module, method,
# even if statements. For this reason, the block parsing method must be
# invoked explicitly out of efficiency sake.
#
# @abstract Subclass this class to provide a handler for YARD to use
#   during the processing phase.
#
# @see CodeObjects::Base
# @see CodeObjects::NamespaceObject
# @see handles
# @see #namespace
# @see #owner
# @see #register
# @see #parse_block
class YARD::Handlers::Base
  # @return [Processor] the processor object that manages all global state
  #   during handling.
  attr_reader parser: YARD::Handlers::Processor
  # @return [Object] the statement object currently being processed. Usually
  #   refers to one semantic language statement, though the strict definition
  #   depends on the parser used.
  attr_reader statement: untyped
  # Returns the value of attribute owner.
  attr_accessor owner: untyped
  # Returns the value of attribute namespace.
  attr_accessor namespace: untyped
  # Returns the value of attribute visibility.
  attr_accessor visibility: untyped
  # Returns the value of attribute scope.
  attr_accessor scope: untyped
  # Returns the value of attribute globals.
  attr_reader globals: untyped
  # Returns the value of attribute extra_state.
  attr_reader extra_state: untyped
  # Clear all registered subclasses. Testing purposes only
  # @return [void]
  def self.clear_subclasses: () -> void
  # Returns all registered handler subclasses.
  # @return [Array<Base>] a list of handlers
  def self.subclasses: () -> Array[YARD::Handlers::Base]
  def self.inherited: (untyped subclass) -> untyped
  def self.handles: (*YARD::Parser::Ruby::Legacy::RubyToken | Symbol | String | Regexp matches) -> untyped
  # This class is implemented by {Ruby::Base} and {Ruby::Legacy::Base}.
  # To implement a base handler class for another language, implement
  # this method to return true if the handler should process the given
  # statement object. Use {handlers} to enumerate the matchers declared
  # for the handler class.
  #
  # @param statement a statement object or node (depends on language type)
  # @return [Boolean] whether or not this handler object should process
  #   the given statement
  def self.handles?: (untyped statement) -> bool
  # @return [Array] a list of matchers for the handler object.
  # @see handles?
  def self.handlers: () -> Array[untyped]
  # Declares that the handler should only be called when inside a
  # {CodeObjects::NamespaceObject}, not a method body.
  #
  # @return [void]
  def self.namespace_only: () -> void
  # @return [Boolean] whether the handler should only be processed inside
  #   a namespace.
  def self.namespace_only?: () -> bool
  # Declares that a handler should only be called when inside a filename
  # by its basename or a regex match for the full path.
  #
  # @param [String, Regexp] filename a matching filename or regex
  # @return [void]
  # @since 0.6.2
  def self.in_file: (String | Regexp filename) -> void
  # @return [Boolean] whether the filename matches the declared file
  #   match for a handler. If no file match is specified, returns true.
  # @since 0.6.2
  def self.matches_file?: (untyped filename) -> bool
  # Generates a +process+ method, equivalent to +def process; ... end+.
  # Blocks defined with this syntax will be wrapped inside an anonymous
  # module so that the handler class can be extended with mixins that
  # override the +process+ method without alias chaining.
  #
  # @!macro yard.handlers.process
  #   @!method process
  #   Main processing callback
  #   @return [void]
  # @see #process
  # @return [void]
  # @since 0.5.4
  def self.process: () -> void
  def initialize: (untyped source_parser, untyped stmt) -> void
  def process: () -> (Array[YARD::CodeObjects::Base] | YARD::CodeObjects::Base | untyped)
  # Parses the semantic "block" contained in the statement node.
  #
  # @abstract Subclasses should call {Processor#process parser.process}
  def parse_block: (*untyped) -> untyped
  # Aborts a handler by raising {Handlers::HandlerAborted}.
  # An exception will only be logged in debugging mode for
  # this kind of handler exit.
  #
  # @since 0.8.4
  def abort!: () -> untyped
  # Executes a given block with specific state values for {#owner},
  # {#namespace} and {#scope}.
  #
  # @option opts [CodeObjects::NamespaceObject] :namespace (value of #namespace)
  #   the namespace object that {#namespace} will be equal to for the
  #   duration of the block.
  # @option opts [Symbol] :scope (:instance)
  #   the scope for the duration of the block.
  # @option opts [CodeObjects::Base] :owner (value of #owner)
  #   the owner object (method) for the duration of the block
  # @yield a block to execute with the given state values.
  def push_state: (?Hash[untyped, untyped] opts) -> untyped
  def register: (*Array[YARD::CodeObjects::Base] objects) -> (YARD::CodeObjects::Base | Array[YARD::CodeObjects::Base])
  # Ensures that the object's namespace is loaded before attaching it
  # to the namespace.
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_ensure_loaded: (YARD::CodeObjects::Base object) -> void
  # Registers the file/line of the declaration with the object
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_file_info: (YARD::CodeObjects::Base object, ?untyped file, ?untyped line, ?untyped comments) -> void
  # Registers any docstring found for the object and expands macros
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_docstring: (YARD::CodeObjects::Base object, ?untyped docstring, ?untyped stmt) -> void
  # Registers the object as being inside a specific group
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_group: (YARD::CodeObjects::Base object, ?untyped group) -> void
  # Registers any transitive tags from the namespace on the object
  #
  # @param [CodeObjects::Base, nil] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_transitive_tags: (YARD::CodeObjects::Base? object) -> void
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_source: (YARD::CodeObjects::Base object, ?untyped source, ?untyped `type`) -> void
  # Registers visibility on a method object. If the object does not
  # respond to setting visibility, nothing is done.
  #
  # @param [#visibility=] object the object to register
  # @param [Symbol] visibility the visibility to set on the object
  # @since 0.8.0
  def register_visibility: (untyped object, ?Symbol visibility) -> untyped
  # Registers the same method information on the module function, if
  # the object was defined as a module function.
  #
  # @param [CodeObjects::Base] object the possible module function object
  #   to copy data for
  # @since 0.8.0
  def register_module_function: (YARD::CodeObjects::Base object) -> untyped
  # Registers the object as dynamic if the object is defined inside
  # a method or block (owner != namespace)
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_dynamic: (YARD::CodeObjects::Base object) -> void
  # Ensures that a specific +object+ has been parsed and loaded into the
  # registry. This is necessary when adding data to a namespace, for instance,
  # since the namespace may not have been processed yet (it can be located
  # in a file that has not been handled).
  #
  # Calling this method defers the handler until all other files have been
  # processed. If the object gets resolved, the rest of the handler continues,
  # otherwise an exception is raised.
  #
  # @example Adding a mixin to the String class programmatically
  #   ensure_loaded! P('String')
  #   # "String" is now guaranteed to be loaded
  #   P('String').mixins << P('MyMixin')
  #
  # @param [Proxy, CodeObjects::Base] object the object to resolve.
  # @param [Integer] max_retries the number of times to defer the handler
  #   before raising a +NamespaceMissingError+.
  # @raise [NamespaceMissingError] if the object is not resolved within
  #   +max_retries+ attempts, this exception is raised and the handler
  #   finishes processing.
  def ensure_loaded!: (untyped | YARD::CodeObjects::Base object, ?Integer max_retries) -> untyped
  # @abstract Implement this method to return the parameters in a method call
  #   statement. It should return an empty list if the statement is not a
  #   method call.
  # @return [Array<String>] a list of argument names
  def call_params: () -> Array[String]
  # @abstract Implement this method to return the method being called in
  #   a method call. It should return nil if the statement is not a method
  #   call.
  # @return [String] the method name being called
  # @return [nil] if the statement is not a method call
  def caller_method: () -> String?
end
